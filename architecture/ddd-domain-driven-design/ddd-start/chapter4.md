# Chapter4 리포지터리와 모델 구현

## 리포지터리와 모델구현\(JPA 중심\)

* JPA를 이용한 리포지터리 기능 구현
* 엔티티와 밸류 매핑
* 밸류 컬렉션 매핑
* 애그리거트 로딩전략과 영속성 전파
* 식별자 생성기능

### JPA를 이용한 리포지터리 기능 구현

#### 레포지터리 기본 기능 구현

* 아이디로 애그리거트 조회하기
* 애그리거트 저장하기

### 매핑 구현

애그리거트와 JPA 매핑을 위한 기본 규칙은 다음과 같다.

* 애그리거트 루트는 엔티티이므로 @Entity로 매핑 설정한다.
* 한 테이블에 엔티티와 밸류 데이터가 같이 있다면
  * 밸류는 @Embeddable로 매핑 설정한다.
  * 밸류 타입 프로퍼티는 @Embedded로 매핑 설정 한다.

#### 기본 생성자

JPA의 @Entity와 @Embeddable로 클래스를 매핑하려면 기본 생성자를 제공해야 한다.

하이버네이트와 같은 JPA 프로바이더는 DB에서 데이터를 읽어와 매핑된 객체를 생성할 때 기본 생성자를 사용해서 객체를 생성한다.

이런 기술적인 제약으로 Receiver와 같은 불변 타입은 기본 생성자가 필요 없음에도 불구하고 다음과 같은 기본 생성자를 추가해야 한다.

즉 기본 생성자는 JPA 프로바이더가 객체를 생성할 때만 사용한다.

또한 기본 생성자를 다른 코드에서 사용하면 값이 없는 온전하지 못한 객체를 만들기 때문에 다른 코드에서 기본 생성자를 사용하지 못하도록 protected로 선언해야 한다.

#### 필드 접근 방식 사용

JPA는 필드와 메서드 두가지 방식으로 매핑 처리를 할 수 있다.

메서드 방식을 사용하려면 get/set 메서드를 구현하면 된다.

엔티티에 프로피터를 위한 공개 get/set 메서드를 추가하면 도메인의 의도가 사리지고 객체가 아닌 데이터 기반으로 엔티티를 구현할 가능성이 높아진다. set 메서드는 내부 데이터를 외부에서 변경할 수 있는 수단이 되기 때문에 캡슐화를 꺠는 원인이 될 수 있다.

엔티티가 객체로서 제 역할을 하려면 외부에 set 메서드 대신 의도가 잘 드러나는 기능을 제공해야 한다.

상태 변경을 위한 setState\(\) 메서드보다 주문 취소를 위한 cancel\(\) 메서드가 도메인을 더 잘 표현하고, setShoppingInfo\(\) 메서드보다 배송지를 변경한다는 의미를 갖는 changeShippingInfo\(\)가 도메인을 더 잘 표현한다.

밸류 타입을 불변으로 구현하고 싶은 경우 set 메서드 자체가 필요 없는데 JPA의 구현 방식 때문에 공개 set 메서드를 추가하는 것도 좋지 않다.

엔티티를 객체가 제공할 기능 중심으로 구현하도록 유도하려면 JPA 매핑 처리를 프로퍼티 방식이 아닌 필드 방식으로 선택해서 불필요한 get/set 메서드를 구현하지 말아야 한다.

