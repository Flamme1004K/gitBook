---
description: 이 글은 김영한님의 jpa책을 보고 공부한 흔적입니다.
---

# Chap1

## \[chapter 1\] JPA 소개 @Flamme

1. SQL을 직접 다룰 때 발생하는 문제점
2. 패러다임의 불일치
3. JPA란 무엇일까?
4. 정리

### 1. SQL을 직접 다룰 때 발생하는 문제점

현재 자바 개발자들 대부분은 JDBC API를 사용하여 SQL을 데이터베이스에 전달하는데 능숙하고 이것을 당연시 하고 있다.

이러한 이유로 자바 개발자들 대표적으로

1.1 반복, 반복 그리고 반복

1.2 SQL에 의존적인 개발

이러한 문제점에 부딛힌다.

**1.1 반복, 반복 그리고 반복**

Ibatis나 Mybatis를 쓸 떄 우리는 항상 CRUD에 해당하는 SQL문을 항상 반복적으로 생성한다.

그 이유는 데이터베이스가 객체 구조와는 다른 데이터 중심의 구조를 가지므로 객체를 데이터베이스에 직접 저장하거 직접 조회 할 수 없기 때문이다. 즉, 개발자가 객체지향 애플리케이션과 데이터베이스 중간에서 SQL과 JDBC API를 사용해서 변환 작업을 직접 해줘야 한다는 것이다.

그리고 이 과정 중에서 많은 SQL문과 JDBC API를 코드로 작성해야 한다는 점, 그리고 테이블 마다 이런 비슷한 일을 반복해야하기 때문이다.

**1.2 SQL에 의존적인 개발**

JDBC API를 사용할때 조회, 추가, 수정 삭제에 대해서 요구사항이 바뀌면 SQL문과 JDBC API를 수정해줘야하기 때문에 SQL에 의존적인 개발을 할 수 밖에 없다.

이 두가지 문제를 요약하자면 이렇다.

* 진정한 의미의 계층 분할이 어렵다.
* 엔티티를 신뢰 할 수 없다.
* SQL에 의존적인 개발을 피하기 어렵다.

그러면 우리는 어떻게 이러한 문제를 해결할 수 있는가? 이 문제를 해결해주는 해결책으로 나온것이 바로 JPA라는 개념이다.

**1.3 JPA와 문제 해결**

JPA를 사용하면 객체를 데이터베이스에 저장하고 관리할 때, 개발자가 직접 SQL을 작성하는 것이 아니라 JPA가 제공하는 API를 사용하면 된다. 그러면 JPA가 개발자 대신에 적절한 SQL을 생성해서 데이터베이스에 전달한다. 이렇게 SQL에 의존적인 개발을 피할 수 있다.

```java
 //저장기능
 jpa.persist(member);

 //조회기능
 String memberId = "HelloID";
 Member member = jpa.find(Member.class, memberId);

 //수정기능
 Member member = jpa.find(Member.class, memberId);
 member.setName("이름변경");

 //연관된 객체조회
 Member member = jpa.find(Member.class, memberId);
 Team team = member.getTeam
```

위의 예제로 엔티티를 신뢰 할 수 있고, 연관된 객체조회처럼 계층 분할이 가능하도록 JPA는 제공한다. 또한 API가 자동적으로 테이블과 맵핑해주기 때문에 SQL 쿼리문을 짜는 시간도 절약해준다.

### 2. 패러다임의 불일치

현재 자바에서 추구하는 객체지향 프로그래밍은 추상화, 캡슐화, 정보은닉, 상속, 다형성 등 시스템의 복잡성을 제어할 수 있는 다양한 장치들을 제공한다. 그래서 현대의 복잡한 애플리케이션은 대부분 객체지향 언어로 개발 한다.

하지만 현재 JPA를 사용하지않고 관계형 데이터베이스를 사용하면 데이터 중심으로 구조화가 되고, 집합적인 사고를 요구하며 객체지향에서 이야기하는 추상화, 상속, 다형성의 개념을 사용하지 않는다.

이러한 이유로 개발자가 중간에서 패러다임의 불일치를 해결해줘야 한다.

이 문제를 JPA는 자바 컬렉션에 객체를 저장하듯이 값들을 저장한다.

### 3. JPA란 무엇인가?

지금까지 JPA와 JDBC API의 차이점을 봐왔다.

현재까지 JPA라는 개념은 의존적인 개발을 할 수 있게하고, 명확한 엔티티를 사용하게하고, 계층분활을 시켜줄뿐만아니라 지금까지 데이터 중심으로 구조화된 관계형 데이터베이스를 자바 객체지향 프로그래밍을 이용하게 함으로써 패러다임의 불일치를 해소해준다.

대체 JPA는 어디서 나왔을까?

`바로 자바 진영의 ORM기술 표준에서 나왔으며, JPA는 어플리케이션과 JDBC 사이에서 작동한다.`

그러면 ORM은 무엇일까?

`ORM은 Object-Relational Mapping이라고 하며 이름 그대로 객체와 관계형 데이터베이스를 매핑한다는 뜻이다.`

즉 ORM 프레임워크는 객체와 테이블을 매핑해서 패러다임의 불일치 문제를 개발자 대신 해결해 준다.

```java
 jpa.persist(member); //저장
```

위 예제와 같이 객체를 저장하도록 도와준다는 것이다.

그리고 ORM이 있기 때문에 패러다임의 불일치를 해소시켜준다.

* 객체 측면에서는 정교한 객체 모델링을 할 수 있고 관계형 데이터베이스는 데이터베이스에 맞도록 모델링 해주면 된다.

패러다임의 불일치 중에서 매핑 또한 ORM에게 매핑 방법만 전달해주면 된다. 이래서 개발자는 데이터중심인 관계형 데이터베이스를 사용해도 객체지향 애플리케이션 개발에 집중 할 수 있다.

또한 ORM에서 패러다임의 불일치를 도와주는 프레임워크도 있는데 바로 하이버네이트라고 한다.

`하이버네이트는 거의 대부분의 패러다임 불일치 문제를 해결해주는 성숙한 ORM 프레임워크이다.`

**3.1 JPA소개**

과거 ORM은 너무 복잡하고 기술 성숙도도 떨어졌으며 자바 엔터프라이즈 애플리케이션 서버에서만 동작했다. 이때 하이버네이트라는 오픈소스 ORM 프레임워크가 등장했는데 EJB의 ORM 기술과 비교해서 가볍고 실용적인 데다 기술 성숙도도 높았다. 또한 자바 엔터프라이즈 애플리케이션 서버 없이도 동작해서 많은 개발자가 사용하기 시작했고, 결국 EJB 3.0에서 하이버네이트를 기반으로 새로운 자바 ORM 기술 표준이 만들어졌는데 이것이 바로 JPA이다. ￿

`JPA는 자바 ORM 기술에 대한 API 표준 명세다.`

JPA가 나오면서 특정 구현 기술에 대한 의존도를 줄일 수 있고 다른 구 현 기술로 손쉽게 이동할 수 있는 장점이 있다. 그리고 JPA표준은 일반적이고 공통적인 기능의 모음이다. 따라서 표준을 먼저 이해하고 고유의 기능을 알아가면 된다.

**3.2 왜 JPA를 사용하는가?**

* 생산성
* 유지보수
* 패러다임의 불일치
* 성능
* 데이터 접근 추상화와 벤더 독립성
* 표준



대표적으로 이 6가지 때문에 JPA를 많이 사용한다.



반복적인 코드와 CRUD용 SQL을 개발자가 직접 작성하지 않아도 되고 더 나아가서 JPA에서는 CREATE TABLE 같은 DDL 문을 자동으로 생성해주는 기능도 있기 때문에 데이터베이스 설계 중심의 패러다임을 객체 설계 중심으로 역전시킴으로써 생산성을 높여준다.

엔티티 필드 추가에 대한 수정에 따른 개발자가 작성해야 했던 SQL과 JDBC API코드를 JPA가 대신 처리해주므로 유지보수가 용이하고 도메인 모델을 편리하게 설계 할 수 있게한다.

상속, 연관관계, 객체 그래프 탐색, 비교하기와 같은 패러다임의 불일치 문제를 해결해준다.

애플리케이션과 데이터베이스 사이에서 동작하여 애플리케이션과 데이터베이스 사이에서 다양한 성능 최적화 기회를 제공한다.

JPA는 데이터베이스 사이에 추상화된 데이터 접근 계층을 제공해서 애플리케이션이 특정 데이터베이스 기술에 종속되지 않도록 한다. 이말은 개발환경에서 H2를 사용하고 개발이나 상용 환경은 오라클이나 MYSQL을 사용할 수 있다는 것이다.

JPA는 자바 진영의 ORM 기술 표준이여서 다른 구현 기술로 손쉽게 변경할 수 있다.

이러한 이유로 우리는 JPA와 가깝게 지내야한다.

